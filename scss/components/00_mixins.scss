//Using @include declare-font('FontName', 'font-filename', 400);
@mixin declare-font($font-family, $font-filename, $font-weight: normal, $font-style: normal){
    @font-face{
        font-family: '#{$font-family}';
        font-weight: $font-weight;
        font-style: $font-style;
        src: url('../fonts/#{$font-filename}.eot');
        src: url('../fonts/#{$font-filename}.eot?#iefix') format('embedded-opentype'),
        url('../fonts/#{$font-filename}.woff') format('woff'),
        url('../fonts/#{$font-filename}.ttf') format('truetype'),;
    }
}
@mixin prefixer($property, $value){
    -webkit-#{$property}: #{$value};
       -moz-#{$property}: #{$value};
        -ms-#{$property}: #{$value};
    #{$property}: #{$value};
}
@mixin transition($property: all, $duration: .3s, $easing: ease){
    $transitions: ($property $duration $easing);
    @include prefixer('transition', $transitions);
}
@mixin scale($scale){
    @include prefixer('scale', $scale);
}
@mixin transform($params, $backface: false){
    @include prefixer('transform', $params);
    @if $backface{
        -webkit-backface-visibility: hidden;
                backface-visibility: hidden;
    }
}
/* @include center(true, false); */
@mixin center($horizontal: true, $vertical: true){
    position: absolute;
    @if ($horizontal and $vertical){
        top: 50%;
        left: 50%;
        @include transform (translate(-50%, -50%));
    } @else if ($horizontal){
        left: 50%;
        @include transform (translate(-50%, 0));
    } @else if ($vertical){
        top: 50%;
        @include transform (translate(0, 50%));
    }
}
// @include before(1px, auto, auto,  0, #0054a6,  8px, 8px, false )
@mixin before($top, $right, $bottom,  $left, $background,  $width, $height, $radius: false ) {
    top: $top;
    right: $right;
    bottom: $bottom;
    left: $left;
    background: $background;
    width: $width;
    height: $height;
    position: absolute;
    content: '';
    @if $radius {
        border-radius: $radius;
    }
}

/*  https://github.com/pfist/quantum-shadows
    @include shadow(2);
   ========================================================================== */
@mixin shadow($depth){
    @if $depth == 1{
        box-shadow: 0 1.5px 3px rgba(black, .24),
        0 3px 8px rgba(black, .05);
    }
    @if $depth == 2{
        box-shadow: 0 4px 7px rgba(black, .23),
        0 8px 25px rgba(black, .05);
    }
    @if $depth == 3{
        box-shadow: 0 7px 10px rgba(black, .30),
        0 10px 50px rgba(black, .12);
    }
    @if $depth == 4{
        box-shadow: 0 10px 15px rgba(black, .28),
        0 15px 60px rgba(black, .18);
    }
    @if $depth == 5{
        box-shadow: 0 16px 20px rgba(black, .29),
        0 20px 65px rgba(black, .18);
    }
}
// .selector {
//   @include placeholder {
//   }
// }
@mixin placeholder{
    &::-webkit-input-placeholder{
        @content;
    }
    &::-moz-placeholder{
        opacity: 1;
        @content ;
    }
    &:-ms-input-placeholder{
        @content ;
    }
}
/* ==========================================================================
   HAMBURGER
   ========================================================================== */
// Vendor prefixes
$b_vendor: true !default;
// Burger
@mixin burger($width: 30px, $height: 5px, $gutter: 3px, $color: #000, $border-radius: 0, $transition-duration: .3s) {
    $burger-height: $height;
    $burger-gutter: $gutter ;
    position: relative;
    margin-top: $height + $gutter;
    margin-bottom: $height + $gutter;
    @if $b_vendor {
        -webkit-user-select: none;
        -moz-user-select: none;
    }
    user-select: none;
    &, &::before, &::after {
        display: block;
        width: $width;
        height: $height;
        background-color: $color;
        @if $border-radius != 0 {
            border-radius: $border-radius;
        }
      & {
          display: inline-block;
      }
        @if $b_vendor {
            -webkit-transition-property: background-color, -webkit-transform;
            -moz-transition-property: background-color, -moz-transform;
        }
        transition-property: background-color, transform;
        @if $b_vendor {
            -webkit-transition-duration: $transition-duration;
            -moz-transition-duration: $transition-duration;
        }
        transition-duration: $transition-duration;
    }
    &::before, &::after {
        position: absolute;
        content: "";
    }
    &::before {
        top: -($height + $gutter);
    }
    &::after {
        top: $height + $gutter;
    }
}
// Select parts of the burger
@mixin burger-parts {
    &, &::before, &::after {
        @content;
    }
}
@mixin burger-top {
    &::before {
        @content;
    }
}
@mixin burger-middle {
    & {
        @content;
    }
}
@mixin burger-bottom {
    &::after {
        @content;
    }
}
// Burger animations
@mixin burger-to-cross {
    & {
        background-color: transparent;
    }
    &::before {
        @if $b_vendor {
            -webkit-transform: translateY($burger-gutter + $burger-height) rotate(45deg);
            -moz-transform: translateY($burger-gutter + $burger-height) rotate(45deg);
        }
        transform: translateY($burger-gutter + $burger-height) rotate(45deg);
    }
    &::after {
        @if $b_vendor {
            -webkit-transform: translateY(-($burger-gutter + $burger-height)) rotate(-45deg);
            -moz-transform: translateY(-($burger-gutter + $burger-height)) rotate(-45deg);
        }
        transform: translateY(-($burger-gutter + $burger-height)) rotate(-45deg);
    }
}
/* ===================================== https://demos.scotch.io/visual-guide-to-css3-flexbox-flexbox-playground/demos ===================================== */
// Flexbox Containers
//
// The 'flex' value causes an element to generate a block-level flex
// container box.
//
// The 'inline-flex' value causes an element to generate a inline-level
// flex container box.
//
// display: flex | inline-flex
@mixin flexbox{
    display: -webkit-box;
    display: -webkit-flex;
    display:    -moz-flex;
    display: -ms-flexbox;
    display:         flex;
}
//%flexbox { @include flexbox; }
@mixin inline-flex{
    display: -webkit-inline-box;
    display: -webkit-inline-flex;
    display:    -moz-inline-flex;
    display: -ms-inline-flexbox;
    display:         inline-flex;
}
//%inline-flex { @include inline-flex; }
// Flexbox Direction
//
// The 'flex-direction' property specifies how flex items are placed in
// the flex container, by setting the direction of the flex container's
// main axis. This determines the direction that flex items are laid out in.
//
// Values: row | row-reverse | column | column-reverse
// Default: row
@mixin flex-direction($value: row){
            flex-direction: $value;
    -webkit-flex-direction: $value;
       -moz-flex-direction: $value;
        -ms-flex-direction: $value;
    @if $value == row-reverse{
        -webkit-box-direction: reverse;
        -webkit-box-orient: horizontal;
    } @else if $value == column{
        -webkit-box-direction: normal;
        -webkit-box-orient: vertical;
    } @else if $value == column-reverse{
        -webkit-box-direction: reverse;
        -webkit-box-orient: vertical;
    } @else{
        -webkit-box-direction: normal;
        -webkit-box-orient: horizontal;
    }
}
// Flexbox Wrap
//
// The 'flex-wrap' property controls whether the flex container is single-line
// or multi-line, and the direction of the cross-axis, which determines
// the direction new lines are stacked in.
//
// Values: nowrap | wrap | wrap-reverse
// Default: nowrap
@mixin flex-wrap($value: nowrap){
    // No Webkit Box fallback.
    -webkit-flex-wrap: $value;
       -moz-flex-wrap: $value;
            flex-wrap: $value;
    @if $value == nowrap{
        -ms-flex-wrap: none;
    } @else{
        -ms-flex-wrap: $value;
    }
}
// Flexbox Flow (shorthand)
//
// The 'flex-flow' property is a shorthand for setting the 'flex-direction'
// and 'flex-wrap' properties, which together define the flex container's
// main and cross axes.
//
// Values: <flex-direction> | <flex-wrap>
// Default: row nowrap
@mixin flex-flow($values: (row nowrap)) {
  // No Webkit Box fallback.
  -webkit-flex-flow: $values;
  -moz-flex-flow: $values;
  -ms-flex-flow: $values;
  flex-flow: $values;
}
//----------------------------------------------------------------------
// Flexbox Order
//
// The 'order' property controls the order in which flex items appear within
// their flex container, by assigning them to ordinal groups.
//
// Default: 0
@mixin order($int: 0) {
  -webkit-box-ordinal-group: $int + 1;
  -webkit-order: $int;
  -moz-order: $int;
  -ms-flex-order: $int;
  order: $int;
}
// Flexbox Grow
//
// The 'flex-grow' property sets the flex grow factor. Negative numbers
// are invalid.
//
// Default: 0
@mixin flex-grow($int: 0) {
  -webkit-box-flex: $int;
  -webkit-flex-grow: $int;
  -moz-flex-grow: $int;
  -ms-flex-positive: $int;
  flex-grow: $int;
}
// Flexbox Shrink
//
// The 'flex-shrink' property sets the flex shrink factor. Negative numbers
// are invalid.
//
// Default: 1
//
// http://w3.org/tr/css3-flexbox/#flex-shrink-property
@mixin flex-shrink($int: 1) {
  -webkit-flex-shrink: $int;
  -moz-flex-shrink: $int;
  -ms-flex-negative: $int;
  flex-shrink: $int;
}
// Flexbox Basis
//
// The 'flex-basis' property sets the flex basis. Negative lengths are invalid.
//
// Values: Like "width"
// Default: auto
@mixin flex-basis($value: auto) {
    @include prefixer('flex-basis', $value);
}
// Flexbox "Flex" (shorthand)
//
// The 'flex' property specifies the components of a flexible length: the
// flex grow factor and flex shrink factor, and the flex basis. When an
// element is a flex item, 'flex' is consulted instead of the main size
// property to determine the main size of the element. If an element is
// not a flex item, 'flex' has no effect.
//
// Values: none | <flex-grow> <flex-shrink> || <flex-basis>
// Default: See individual properties (1 1 0).
@mixin flex($fg: 1, $fs: null, $fb: null) {
  $fg-boxflex: $fg;
  @if type-of($fg) == 'list' {
    $fg-boxflex: nth($fg, 1);
  }
  -webkit-box-flex: $fg-boxflex;
  -webkit-flex: $fg $fs $fb;
  -moz-box-flex: $fg-boxflex;
  -moz-flex: $fg $fs $fb;
  -ms-flex: $fg $fs $fb;
  flex: $fg $fs $fb;
}
// Flexbox Justify Content
//
// The 'justify-content' property aligns flex items along the main axis
// of the current line of the flex container. This is done after any flexible
// lengths and any auto margins have been resolved. Typically it helps distribute
// extra free space leftover when either all the flex items on a line are
// inflexible, or are flexible but have reached their maximum size. It also
// exerts some control over the alignment of items when they overflow the line.
//
// Note: 'space-*' values not supported in older syntaxes.
//
// Values: flex-start | flex-end | center | space-between | space-around
// Default: flex-start
@mixin justify-content($value: flex-start) {
  @if $value == flex-start {
    -webkit-box-pack: start;
    -ms-flex-pack: start;
  } @else if $value == flex-end {
    -webkit-box-pack: end;
    -ms-flex-pack: end;
  } @else if $value == space-between {
    -webkit-box-pack: justify;
    -ms-flex-pack: justify;
  } @else if $value == space-around {
    -ms-flex-pack: distribute;
  } @else {
    -webkit-box-pack: $value;
    -ms-flex-pack: $value;
  }
  -webkit-justify-content: $value;
  -moz-justify-content: $value;
  justify-content: $value;
}
// Flexbox Align Items
// Flex items can be aligned in the cross axis of the current line of the
// flex container, similar to 'justify-content' but in the perpendicular
// direction. 'align-items' sets the default alignment for all of the flex
// container's items, including anonymous flex items. 'align-self' allows
// this default alignment to be overridden for individual flex items. (For
// anonymous flex items, 'align-self' always matches the value of 'align-items'
// on their associated flex container.)
// Values: flex-start | flex-end | center | baseline | stretch
// Default: stretch
@mixin align-items($value: stretch) {
  @if $value == flex-start {
    -webkit-box-align: start;
    -ms-flex-align: start;
  } @else if $value == flex-end {
    -webkit-box-align: end;
    -ms-flex-align: end;
  } @else {
    -webkit-box-align: $value;
    -ms-flex-align: $value;
  }
  -webkit-align-items: $value;
  -moz-align-items: $value;
  align-items: $value;
}
// Flexbox Align Self
// Values: auto | flex-start | flex-end | center | baseline | stretch
// Default: auto
@mixin align-self($value: auto) {
  // No Webkit Box Fallback.
  -webkit-align-self: $value;
  -moz-align-self: $value;
  @if $value == flex-start {
    -ms-flex-item-align: start;
  } @else if $value == flex-end {
    -ms-flex-item-align: end;
  } @else {
    -ms-flex-item-align: $value;
  }
  align-self: $value;
}
// Flexbox Align Content
//
// The 'align-content' property aligns a flex container's lines within the
// flex container when there is extra space in the cross-axis, similar to
// how 'justify-content' aligns individual items within the main-axis. Note,
// this property has no effect when the flexbox has only a single line.
//
// Values: flex-start | flex-end | center | space-between | space-around | stretch
// Default: stretch
//
@mixin align-content($value: stretch) {
  -webkit-align-content: $value;
  -moz-align-content: $value;
  @if $value == flex-start {
    -ms-flex-line-pack: start;
  } @else if $value == flex-end {
    -ms-flex-line-pack: end;
  } @else {
    -ms-flex-line-pack: $value;
  }
  align-content: $value;
}
/*
    Flexbox grid @mixin
    EXAMPLE
    .flexbox {
        @include boxGrid(5, 4%);
        > div {
            margin-bottom: .4em;
            background: #333;
            padding: .8em;
            color: #fff;
        }
    }
*/
@mixin boxGrid($columnNumber, $spacingPercent) {
  $contentPercent: 100%;
  $sideMargin: ($spacingPercent/2);
  $marginInt: strip-units($sideMargin);
  @include justify-content(flex-start);
  @include flex-flow(wrap);
  @include transition();
  @include flexbox();
  margin: 0 -$sideMargin;
  width: $contentPercent + $spacingPercent;
  > * {
    width: ($contentPercent/$columnNumber) - $spacingPercent;
    margin: 0 #{$sideMargin} ($marginInt + ($marginInt / $columnNumber) * 1em)
  }
}
